delayMicroseconds(us) <split>Pauses the program for the amount of time (in microseconds) specified as parameter. <split>us: the number of microseconds to pause (unsigned int)
digitalRead(pin) <split>Reads the value from a specified digital pin, either HIGH or LOW. <split>pin: the number of the digital pin you want to read
micros() <split>the number of microseconds since the Arduino board began running the current program. This number will overflow (go back to zero), after approximately 70 minutes. On 16 MHz Arduino boards (e.g. Duemilanove and Nano), this function has a resolution of four microseconds (i.e. the value returned is always a multiple of four). On 8 MHz Arduino boards (e.g. the LilyPad), this function has a resolution of eight microseconds.
pow(base, exponent) <split>Calculates the value of a number raised to a power. <split>base: the number (float)exponent: the power to which the base is raised (float)
analogReference(type) <split>Configures the reference voltage used for analog input <split>type: which type of reference to use (see list of options in the description).
analogRead(pin) <split>Reads the value from the specified analog pin. <split>pin: the number of the analog input pin to read from (0 to 5 on most boards, 0 to 7 on the Mini and Nano, 0 to 15 on the Mega)
pinMode(pin, mode) <split>Configures the specified pin to behave either as an input or an output. <split>pin: the number of the pin whose mode you wish to setmode: INPUT, OUTPUT, or INPUT_PULLUP.
noTone(pin) <split>Stops the generation of a square wave triggered by tone(). <split>pin: the pin on which to stop generating the tone
constrain(x, a, b) <split>Constrains a number to be within a range. <split>x: the number to constrain, all data typesa: the lower end of the range, all data typesb: the upper end of the range, all data types
isDigit(thisChar) <split>true if thisChar is a number. <split>Analyse if a char is a digit (that is a number).
isAscii(thisChar) <split>true if thisChar contains an Ascii character. <split>Analyse if a char is Ascii.
analogWrite(pin, value) <split>Writes an analog value (PWM wave) to a pin. Can be used to light a LED at varying brightnesses or drive a motor at various speeds. <split>pin: the pin to write to. Allowed data types: int.value: the duty cycle: between 0 (always off) and 255 (always on). Allowed data types: int
shiftIn(dataPin, clockPin, bitOrder) <split>Shifts in a byte of data one bit at a time. <split>dataPin: the pin on which to input each bit (int)clockPin: the pin to toggle to signal a read from dataPinbitOrder: which order to shift in the bits; either MSBFIRST or LSBFIRST.(Most Significant Bit First, or, Least Significant Bit First)
tone(pin, frequency)tone(pin, frequency, duration) <split>Generates a square wave of the specified frequency (and 50% duty cycle) on a pin. <split>pin: the pin on which to generate the tonefrequency: the frequency of the tone in hertz - unsigned intduration: the duration of the tone in milliseconds (optional) - unsigned long
max(x, y) <split>Calculates the maximum of two numbers. <split>x: the first number, any data typey: the second number, any data type
sqrt(x) <split> takes square root <split>x: the number, any data type
bit(n) <split>Computes the value of the specified bit <split>n: the bit whose value to compute
cos(rad) <split>Calculates the cosine of an angle (in radians). The result will be between -1 and 1. <split>rad: The angle in Radians (float).
map(value, fromLow, fromHigh, toLow, toHigh) <split>Re-maps a number from one range to another. <split>value: the number to mapfromLow: the lower bound of the value’s current rangefromHigh: the upper bound of the value’s current rangetoLow: the lower bound of the value’s target rangetoHigh: the upper bound of the value’s target range
delay(ms) <split>Pauses the program for the amount of time (in milliseconds) specified as parameter. <split>ms: the number of milliseconds to pause (unsigned long)
sin(rad) <split>Calculates the sine of an angle (in radians). The result will be between -1 and 1. <split>rad: The angle in Radians (float).
isAlphaNumeric(thisChar) <split>true if thisChar contains either a number or a letter. <split>Analyse if a char is alphanumeric (that is a letter or a numbers).
isLowerCase(thisChar) <split>true if thisChar contains a letter in lower case. <split>Analyse if a char is lower case (that is a letter in lower case).
digitalWrite(pin, value) <split>Write a HIGH or a LOW value to a digital pin. <split>pin: the number of the digital pin you want to read.
isHexadecimalDigit(thisChar) <split>true if thisChar contains an hexadecimal digit. <split>Analyse if a char is an hexadecimal digit (A-F, 0-9).
isGraph(thisChar) <split>true if thisChar is printable. <split>Analyse if a char is printable with some content (space is printable but has no content).
lowByte(x) <split>Extracts the low-order (rightmost) byte of a variable (e.g. a word). <split>x: a value of any type
highByte(x) <split>Extracts the high-order (leftmost) byte of a word (or the second lowest byte of a larger data type). <split>x: a value of any type
random(max)random(min, max) <split>The random function generates pseudo-random numbers. <split>min - lower bound of the random value, inclusive (optional)max - upper bound of the random value, exclusive
abs(x) <split>Calculates the absolute value of a number. <split>x: the number
analogWriteResolution(bits) <split>analogWriteResolution() is an extension of the Analog API for the Arduino Due.analogWriteResolution() sets the resolution of the analogWrite() function. It defaults to 8 bits (values between 0-255) for backward compatibility with AVR based boards.The Due has the following hardware capabilities:12 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed to 12-bit resolution.2 pins with 12-bit DAC (Digital-to-Analog Converter)By setting the write resolution to 12, you can use analogWrite() with values between 0 and 4095 to exploit the full DAC resolution or to set the PWM signal without rolling over.The Zero has the following hardware capabilities:10 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed to 12-bit resolution.1 pin with 10-bit DAC (Digital-to-Analog Converter).By setting the write resolution to 10, you can use analogWrite() with values between 0 and 1023 to exploit the full DAC resolutionThe MKR Family of boards has the following hardware capabilities:4 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed from 8 (default) to 12-bit resolution.1 pin with 10-bit DAC (Digital-to-Analog Converter)By setting the write resolution to 12 bits, you can use analogWrite() with values between 0 and 4095 for PWM signals; set 10 bit on the DAC pin to exploit the full DAC resolution of 1024 values. <split>bits: determines the resolution (in bits) of the values used in the analogWrite() function. The value can range from 1 to 32. If you choose a resolution higher or lower than your board’s hardware capabilities, the value used in analogWrite() will be either truncated if it’s too high or padded with zeros if it’s too low. See the note below for details.
bitWrite(x, n, b) <split>Writes a bit of a numeric variable. <split>x: the numeric variable to which to writen: which bit of the number to write, starting at 0 for the least-significant (rightmost) bitb: the value to write to the bit (0 or 1)
attachInterrupt(digitalPinToInterrupt(pin), ISR, mode);(recommended)attachInterrupt(interrupt, ISR, mode);(not recommended)attachInterrupt(pin, ISR, mode);(not recommended Arduino Due, Zero, MKR1000, 101 only) <split>Digital Pins With InterruptsThe first parameter to attachInterrupt is an interrupt number. Normally you should use digitalPinToInterrupt(pin) to translate the actual digital pin to the specific interrupt number. For example, if you connect to pin 3, use digitalPinToInterrupt(3) as the first parameter to attachInterrupt.BoardDigital Pins Usable For InterruptsUno, Nano, Mini, other 328-based2, 3Mega, Mega2560, MegaADK2, 3, 18, 19, 20, 21Micro, Leonardo, other 32u4-based0, 1, 2, 3, 7Zeroall digital pins, except 4MKR1000 Rev.10, 1, 4, 5, 6, 7, 8, 9, A1, A2Dueall digital pins101all digital pins (Only pins 2, 5, 7, 8, 10, 11, 12, 13 work with CHANGE)Notes and WarningsNoteInside the attached function, delay() won’t work and the value returned by millis() will not increment. Serial data received while in the function may be lost. You should declare as volatile any variables that you modify within the attached function. See the section on ISRs below for more information.Using InterruptsInterrupts are useful for making things happen automatically in microcontroller programs, and can help solve timing problems. Good tasks for using an interrupt may include reading a rotary encoder, or monitoring user input.If you wanted to insure that a program always caught the pulses from a rotary encoder, so that it never misses a pulse, it would make it very tricky to write a program to do anything else, because the program would need to constantly poll the sensor lines for the encoder, in order to catch pulses when they occurred. Other sensors have a similar interface dynamic too, such as trying to read a sound sensor that is trying to catch a click, or an infrared slot sensor (photo-interrupter) trying to catch a coin drop. In all of these situations, using an interrupt can free the microcontroller to get some other work done while not missing the input.About Interrupt Service RoutinesISRs are special kinds of functions that have some unique limitations most other functions do not have. An ISR cannot have any parameters, and they shouldn’t return anything.Generally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time, other interrupts will be executed after the current one finishes in an order that depends on the priority they have. millis() relies on interrupts to count, so it will never increment inside an ISR. Since delay() requires interrupts to work, it will not work if called inside an ISR. micros() works initially, but will start behaving erratically after 1-2 ms. delayMicroseconds() does not use any counter, so it will work as normal.Typically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile.For more information on interrupts, see Nick Gammon’s notes. <split>interrupt: the number of the interrupt (int)pin:       the pin number             (Arduino Due, Zero, MKR1000 only)ISR:       the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.mode:      defines when the interrupt should be triggered. Four constants are predefined as valid values:LOW to trigger the interrupt whenever the pin is low,CHANGE to trigger the interrupt whenever the pin changes valueRISING to trigger when the pin goes from low to high,FALLING for when the pin goes from high to low.The Due, Zero and MKR1000 boards allows also:HIGH to trigger the interrupt whenever the pin is high.
isControl(thisChar) <split>true if thisChar is a control character. <split>Analyse if a char is a control character.
sq(x) <split>Calculates the square of a number: the number multiplied by itself. <split>x: the number, any data type
bitClear(x, n) <split>Clears (writes a 0 to) a bit of a numeric variable. <split>x: the numeric variable whose bit to clearn: which bit to clear, starting at 0 for the least-significant (rightmost) bit
min(x, y) <split>Calculates the minimum of two numbers. <split>x: the first number, any data typey: the second number, any data type
tan(rad) <split>Calculates the tangent of an angle (in radians). The result will be between negative infinity and infinity. <split>rad: The angle in Radians (float).
bitRead(x, n) <split>Reads a bit of a number. <split>x: the number from which to readn: which bit to read, starting at 0 for the least-significant (rightmost) bit
shiftOut(dataPin, clockPin, bitOrder, value) <split>Shifts out a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit. Each bit is written in turn to a data pin, after which a clock pin is pulsed (taken high, then low) to indicate that the bit is available.Note- if you’re interfacing with a device that’s clocked by rising edges, you’ll need to make sure that the clock pin is low before the call to shiftOut(), e.g. with a call to digitalWrite(clockPin, LOW).This is a software implementation; see also the SPI library, which provides a hardware implementation that is faster but works only on specific pins. <split>dataPin: the pin on which to output each bit (int)clockPin: the pin to toggle once the dataPin has been set to the correct value (int)bitOrder: which order to shift out the bits; either MSBFIRST or LSBFIRST.(Most Significant Bit First, or, Least Significant Bit First)value: the data to shift out. (byte)
isAlpha(thisChar) <split>true if thisChar contains a letter. <split>Analyse if a char is alpha (that is a letter).
seed - number to initialize the pseudo-random sequence (unsigned long). <split>randomSeed() initializes the pseudo-random number generator, causing it to start at an arbitrary point in its random sequence. This sequence, while very long, and random, is always the same.If it is important for a sequence of values generated by random() to differ, on subsequent executions of a sketch, use randomSeed() to initialize the random number generator with a fairly random input, such as analogRead() on an unconnected pin.Conversely, it can occasionally be useful to use pseudo-random sequences that repeat exactly. This can be accomplished by calling randomSeed() with a fixed number, before starting the random sequence. <split>
interrupts() <split>Re-enables interrupts (after they’ve been disabled by nointerrupts(). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code. <split>Nothing
noInterrupts() <split>Disables interrupts (you can re-enable them with interrupts()). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code. <split>Nothing
isSpace(thisChar) <split>true if thisChar contains the space character. <split>Analyse if a char is the space character.
isAlpha(thisChar) <split>true if thisChar is printable. <split>Analyse if a char is printable (that is any character that produces an output, even a blank space).
detachInterrupt()detachInterrupt(pin) (Arduino Due only) <split>Turns off the given interrupt. <split>interrupt: the number of the interrupt to disable (see attachInterrupt() for more details).pin: the pin number of the interrupt to disable (Arduino Due only)
bitSet(x, n) <split> <split>x: the numeric variable whose bit to setn: which bit to set, starting at 0 for the least-significant (rightmost) bit
isUpperCase(thisChar) <split>true if thisChar is upper case. <split>Analyse if a char is upper case (that is a letter in upper case).
analogReadResolution(bits) <split>analogReadResolution() is an extension of the Analog API for the Arduino Due, Zero and MKR Family.Sets the size (in bits) of the value returned by analogRead(). It defaults to 10 bits (returns values between 0-1023) for backward compatibility with AVR based boards.The Due, Zero and MKR Family boards have 12-bit ADC capabilities that can be accessed by changing the resolution to 12. This will return values from analogRead() between 0 and 4095. <split>bits: determines the resolution (in bits) of the value returned by the analogRead() function. You can set this between 1 and 32. You can set resolutions higher than 12 but values returned by analogRead() will suffer approximation. See the note below for details.
write(angle) <split>Writes a value to the servo, controlling the shaft accordingly.  On a standard servo, this will set the angle of the shaft (in degrees), moving the shaft to that orientation.  On a continuous rotation servo, this will set the speed of the servo (with 0 being full-speed in one direction, 180 being full speed in the other, and a value near 90 being no movement). <split>
writeMicroseconds(uS) <split>Writes a value in microseconds (uS) to the servo, controlling the shaft accordingly. <split>us: the number of microseconds to pause (unsigned int)
attach(pin) <split>Attach the Servo variable to a pin. <split>pin: the number of the digital pin you want to read
