{"name":"\n\nConfigures the reference voltage used for analog input (i.e. the value used as the top of the input range). The options are:\n\n\nArduino AVR Boards (Uno, Mega, etc.)\n\n\n\n\nDEFAULT: the default analog reference of 5 volts (on 5V Arduino boards) or 3.3 volts (on 3.3V Arduino boards)\n\n\nINTERNAL: an built-in reference, equal to 1.1 volts on the ATmega168 or ATmega328P and 2.56 volts on the ATmega8 (not available on the Arduino Mega)\n\n\nINTERNAL1V1: a built-in 1.1V reference (Arduino Mega only)\n\n\nINTERNAL2V56: a built-in 2.56V reference (Arduino Mega only)\n\n\nEXTERNAL: the voltage applied to the AREF pin (0 to 5V only) is used as the reference.\n\n\n\n\nArduino SAMD Boards (Zero, etc.)\n\n\n\n\nAR_DEFAULT: the default analog reference of 3.3V\n\n\nAR_INTERNAL: a built-in 2.23V reference\n\n\nAR_INTERNAL1V0: a built-in 1.0V reference\n\n\nAR_INTERNAL1V65: a built-in 1.65V reference\n\n\nAR_INTERNAL2V23: a built-in 2.23V reference\n\n\nAR_EXTERNAL: the voltage applied to the AREF pin is used as the reference\n\n\n\n\nArduino SAM Boards (Due)\n\n\n\n\nAR_DEFAULT: the default analog reference of 3.3V. This is the only supported option for the Due.\n\n\n\n","description":"\n\nanalogReference(type)\n\n","syntax":"\n\ntype: which type of reference to use (see list of options in the description).\n\n"}{"name":"\n\nReads the value from the specified analog pin. The Arduino board contains a 6 channel (8 channels on the Mini and Nano, 16 on the Mega), 10-bit analog to digital converter. This means that it will map input voltages between 0 and 5 volts into integer values between 0 and 1023. This yields a resolution between readings of: 5 volts / 1024 units or, .0049 volts (4.9 mV) per unit. The input range and resolution can be changed using analogReference().\n\n\nIt takes about 100 microseconds (0.0001 s) to read an analog input, so the maximum reading rate is about 10,000 times a second.\n\n","description":"\n\nanalogRead(pin)\n\n","syntax":"\n\npin: the number of the analog input pin to read from (0 to 5 on most boards, 0 to 7 on the Mini and Nano, 0 to 15 on the Mega)\n\n"}{"name":"\n\nPauses the program for the amount of time (in milliseconds) specified as parameter. (There are 1000 milliseconds in a second.)\n\n","description":"\n\ndelay(ms)\n\n","syntax":"\n\nms: the number of milliseconds to pause (unsigned long)\n\n"}{"name":"\n\nCalculates the absolute value of a number.\n\n","description":"\n\nabs(x)\n\n","syntax":"\n\nx: the number\n\n"}{"name":"\n\nConstrains a number to be within a range.\n\n","description":"\n\nconstrain(x, a, b)\n\n","syntax":"\n\nx: the number to constrain, all data types\na: the lower end of the range, all data types\nb: the upper end of the range, all data types\n\n"}{"name":"\n\nReads the value from a specified digital pin, either HIGH or LOW.\n\n","description":"\n\ndigitalRead(pin)\n\n","syntax":"\n\npin: the number of the digital pin you want to read\n\n"}{"name":"\n\nStops the generation of a square wave triggered by tone(). Has no effect if no tone is being generated.\n\n","description":"\n\nnoTone(pin)\n\n","syntax":"\n\npin: the pin on which to stop generating the tone\n\n"}{"name":"\n\nPauses the program for the amount of time (in microseconds) specified as parameter. There are a thousand microseconds in a millisecond, and a million microseconds in a second.\n\n\nCurrently, the largest value that will produce an accurate delay is 16383. This could change in future Arduino releases. For delays longer than a few thousand microseconds, you should use delay() instead.\n\n","description":"\n\ndelayMicroseconds(us)\n\n","syntax":"\n\nus: the number of microseconds to pause (unsigned int)\n\n"}{"name":"\n\nWrite a HIGH or a LOW value to a digital pin.\n\n\nIf the pin has been configured as an OUTPUT with pinMode(), its voltage will be set to the corresponding value: 5V (or 3.3V on 3.3V boards) for HIGH, 0V (ground) for LOW.\n\n\nIf the pin is configured as an INPUT, digitalWrite() will enable (HIGH) or disable (LOW) the internal pullup on the input pin. It is recommended to set the pinMode() to INPUT_PULLUP to enable the internal pull-up resistor. See the digital pins tutorial for more information.\n\n\nIf you do not set the pinMode() to OUTPUT, and connect an LED to a pin, when calling digitalWrite(HIGH), the LED may appear dim. Without explicitly setting pinMode(), digitalWrite() will have enabled the internal pull-up resistor, which acts like a large current-limiting resistor.\n\n","description":"\n\ndigitalWrite(pin, value)\n\n","syntax":"\n\npin: the pin number\n\n\nvalue: HIGH or LOW\n\n"}{"name":"\n\nShifts out a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit. Each bit is written in turn to a data pin, after which a clock pin is pulsed (taken high, then low) to indicate that the bit is available.\n\n\nNote- if you’re interfacing with a device that’s clocked by rising edges, you’ll need to make sure that the clock pin is low before the call to shiftOut(), e.g. with a call to digitalWrite(clockPin, LOW).\n\n\nThis is a software implementation; see also the SPI library, which provides a hardware implementation that is faster but works only on specific pins.\n\n","description":"\n\nshiftOut(dataPin, clockPin, bitOrder, value)\n\n","syntax":"\n\ndataPin: the pin on which to output each bit (int)\n\n\nclockPin: the pin to toggle once the dataPin has been set to the correct value (int)\n\n\nbitOrder: which order to shift out the bits; either MSBFIRST or LSBFIRST.\n(Most Significant Bit First, or, Least Significant Bit First)\n\n\nvalue: the data to shift out. (byte)\n\n"}{"name":"\n\nRe-maps a number from one range to another. That is, a value of fromLow would get mapped to toLow, a value of fromHigh to toHigh, values in-between to values in-between, etc.\n\n\nDoes not constrain values to within the range, because out-of-range values are sometimes intended and useful. The constrain() function may be used either before or after this function, if limits to the ranges are desired.\n\n\nNote that the \"lower bounds\" of either range may be larger or smaller than the \"upper bounds\" so the map() function may be used to reverse a range of numbers, for example\n\n\ny = map(x, 1, 50, 50, 1);\n\n\nThe function also handles negative numbers well, so that this example\n\n\ny = map(x, 1, 50, 50, -100);\n\n\nis also valid and works well.\n\n\nThe map() function uses integer math so will not generate fractions, when the math might indicate that it should do so. Fractional remainders are truncated, and are not rounded or averaged.\n\n","description":"\n\nmap(value, fromLow, fromHigh, toLow, toHigh)\n\n","syntax":"\n\nvalue: the number to map\n\n\nfromLow: the lower bound of the value’s current range\n\n\nfromHigh: the upper bound of the value’s current range\n\n\ntoLow: the lower bound of the value’s target range\n\n\ntoHigh: the upper bound of the value’s target range\n\n"}{"name":"\n\n","description":" the number of microseconds since the Arduino board began running the current program. This number will overflow (go back to zero), after approximately 70 minutes. On 16 MHz Arduino boards (e.g. Duemilanove and Nano), this function has a resolution of four microseconds (i.e. the value returned is always a multiple of four). On 8 MHz Arduino boards (e.g. the LilyPad), this function has a resolution of eight microseconds.\n\n","syntax":"\n\ntime = micros()\n\n"}{"name":"\n\nCalculates the minimum of two numbers.\n\n","description":"\n\nmin(x, y)\n\n","syntax":"\n\nx: the first number, any data type\n\n\ny: the second number, any data type\n\n"}{}{"name":"\n\nTurns off the given interrupt.\n\n","description":"\n\ndetachInterrupt()\ndetachInterrupt(pin) \t(Arduino Due only)\n\n","syntax":"\n\ninterrupt: the number of the interrupt to disable (see attachInterrupt() for more details).\n\n\npin: the pin number of the interrupt to disable (Arduino Due only)\n\n"}{"name":"\n\nReads a pulse (either HIGH or LOW) on a pin. For example, if value is HIGH, pulseInLong() waits for the pin to go HIGH, starts timing, then waits for the pin to go LOW and stops timing. ","description":" the length of the pulse in microseconds or 0 if no complete pulse was received within the timeout.\n\n\nThe timing of this function has been determined empirically and will probably show errors in shorter pulses. Works on pulses from 10 microseconds to 3 minutes in length. Please also note that if the pin is already high when the function is called, it will wait for the pin to go LOW and then HIGH before it starts counting. This routine can be used only if interrupts are activated. Furthermore the highest resolution is obtained with large intervals.\n\n","syntax":"\n\npulseInLong(pin, value)\n\n\npulseInLong(pin, value, timeout)\n\n"}{"name":"\n\nDisables interrupts (you can re-enable them with interrupts()). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code.\n\n","description":"\n\nnoInterrupts()\n\n","syntax":"\n\nNothing\n\n"}{"name":"\n\nRe-enables interrupts (after they’ve been disabled by nointerrupts(). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code.\n\n","description":"\n\ninterrupts()\n\n","syntax":"\n\nNothing\n\n"}{"name":"\n\nExtracts the low-order (rightmost) byte of a variable (e.g. a word).\n\n","description":"\n\nlowByte(x)\n\n","syntax":"\n\nx: a value of any type\n\n"}{"name":"\n\nAnalyse if a char is a white space, that is space, formfeed ('\\f'), newline ('\\n'), carriage return ('\\r'), horizontal tab ('\\t'), and vertical tab ('\\v')).\n","description":" true if thisChar contains a white space.\n\n","syntax":"\n\n\nisWhitespace(thisChar)\n\n\n"}{"name":"\n\nReads a pulse (either HIGH or LOW) on a pin. For example, if value is HIGH, pulseIn() waits for the pin to go HIGH, starts timing, then waits for the pin to go LOW and stops timing. ","description":" the length of the pulse in microseconds. Gives up and returns 0 if no pulse starts within a specified time out.\n\n\nThe timing of this function has been determined empirically and will probably show errors in longer pulses. Works on pulses from 10 microseconds to 3 minutes in length.\n\n","syntax":"\n\npulseIn(pin, value)\n\n\npulseIn(pin, value, timeout)\n\n"}{"name":"\n\nCalculates the cosine of an angle (in radians). The result will be between -1 and 1.\n\n","description":"\n\ncos(rad)\n\n","syntax":"\n\nrad: The angle in Radians (float).\n\n"}{"name":"\n\nConfigures the specified pin to behave either as an input or an output. See the description of (digital pins) for details on the functionality of the pins.\n\n\nAs of Arduino 1.0.1, it is possible to enable the internal pullup resistors with the mode INPUT_PULLUP. Additionally, the INPUT mode explicitly disables the internal pullups.\n\n","description":"\n\npinMode(pin, mode)\n\n","syntax":"\n\npin: the number of the pin whose mode you wish to set\n\n\nmode: INPUT, OUTPUT, or INPUT_PULLUP. (see the (digital pins) page for a more complete description of the functionality.)\n\n"}{"name":"\n\nWrites a bit of a numeric variable.\n\n","description":"\n\nbitWrite(x, n, b)\n\n","syntax":"\n\nx: the numeric variable to which to write\n\n\nn: which bit of the number to write, starting at 0 for the least-significant (rightmost) bit\n\n\nb: the value to write to the bit (0 or 1)\n\n"}{"name":"\n\nWrites an analog value (PWM wave) to a pin. Can be used to light a LED at varying brightnesses or drive a motor at various speeds. After a call to analogWrite(), the pin will generate a steady square wave of the specified duty cycle until the next call to analogWrite() (or a call to digitalRead() or digitalWrite()) on the same pin. The frequency of the PWM signal on most pins is approximately 490 Hz. On the Uno and similar boards, pins 5 and 6 have a frequency of approximately 980 Hz.\n\n\nOn most Arduino boards (those with the ATmega168 or ATmega328P), this function works on pins 3, 5, 6, 9, 10, and 11. On the Arduino Mega, it works on pins 2 - 13 and 44 - 46. Older Arduino boards with an ATmega8 only support analogWrite() on pins 9, 10, and 11.\nThe Arduino DUE supports analogWrite() on pins 2 through 13, plus pins DAC0 and DAC1. Unlike the PWM pins, DAC0 and DAC1 are Digital to Analog converters, and act as true analog outputs.\nYou do not need to call pinMode() to set the pin as an output before calling analogWrite().\nThe analogWrite function has nothing to do with the analog pins or the analogRead function.\n\n","description":"\n\nanalogWrite(pin, value)\n\n","syntax":"\n\npin: the pin to write to. Allowed data types: int.\nvalue: the duty cycle: between 0 (always off) and 255 (always on). Allowed data types: int\n\n"}{}{"name":"\n\nShifts in a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit. For each bit, the clock pin is pulled high, the next bit is read from the data line, and then the clock pin is taken low.\n\n\nIf you’re interfacing with a device that’s clocked by rising edges, you’ll need to make sure that the clock pin is low before the first call to shiftIn(), e.g. with a call to digitalWrite(clockPin, LOW).\n\n\nNote: this is a software implementation; Arduino also provides an SPI library that uses the hardware implementation, which is faster but only works on specific pins.\n\n","description":"\n\nbyte incoming = shiftIn(dataPin, clockPin, bitOrder)\n\n","syntax":"\n\ndataPin: the pin on which to input each bit (int)\n\n\nclockPin: the pin to toggle to signal a read from dataPin\n\n\nbitOrder: which order to shift in the bits; either MSBFIRST or LSBFIRST.\n(Most Significant Bit First, or, Least Significant Bit First)\n\n"}{"name":"\n\nAnalyse if a char is the space character. ","description":" true if thisChar contains the space character.\n\n","syntax":"\n\n\n`isSpace(thisChar)`\n\n\n"}{"name":"\n\nanalogReadResolution() is an extension of the Analog API for the Arduino Due, Zero and MKR Family.\n\n\nSets the size (in bits) of the value returned by analogRead(). It defaults to 10 bits (returns values between 0-1023) for backward compatibility with AVR based boards.\n\n\nThe Due, Zero and MKR Family boards have 12-bit ADC capabilities that can be accessed by changing the resolution to 12. This will return values from analogRead() between 0 and 4095.\n\n","description":"\n\nanalogReadResolution(bits)\n\n","syntax":"\n\nbits: determines the resolution (in bits) of the value returned by the analogRead() function. You can set this between 1 and 32. You can set resolutions higher than 12 but values returned by analogRead() will suffer approximation. See the note below for details.\n\n"}{"name":"\n\nAnalyse if a char is a digit (that is a number). ","description":" true if thisChar is a number.\n\n","syntax":"\n\n\nisDigit(thisChar)\n\n\n"}{"name":"\n\nCalculates the tangent of an angle (in radians). The result will be between negative infinity and infinity.\n\n","description":"\n\ntan(rad)\n\n","syntax":"\n\nrad: The angle in Radians (float).\n\n"}{"name":"\n\nAnalyse if a char is printable (that is any character that produces an output, even a blank space). ","description":" true if thisChar is printable.\n\n","syntax":"\n\n\n`isAlpha(thisChar)`\n\n\n"}{"name":"\n","description":"\n\nsqrt(x)\n\n","syntax":"\n\nx: the number, any data type\n\n"}{"name":"\n\nComputes the value of the specified bit (bit 0 is 1, bit 1 is 2, bit 2 is 4, etc.).\n\n","description":"\n\nbit(n)\n\n","syntax":"\n\nn: the bit whose value to compute\n\n"}{"name":"\n\nrandomSeed() initializes the pseudo-random number generator, causing it to start at an arbitrary point in its random sequence. This sequence, while very long, and random, is always the same.\n\n\nIf it is important for a sequence of values generated by random() to differ, on subsequent executions of a sketch, use randomSeed() to initialize the random number generator with a fairly random input, such as analogRead() on an unconnected pin.\n\n\nConversely, it can occasionally be useful to use pseudo-random sequences that repeat exactly. This can be accomplished by calling randomSeed() with a fixed number, before starting the random sequence.\n\n","description":"\n\nseed - number to initialize the pseudo-random sequence (unsigned long).\n\n"}{"name":"\n\nCalculates the value of a number raised to a power. Pow() can be used to raise a number to a fractional power. This is useful for generating exponential mapping of values or curves.\n\n","description":"\n\npow(base, exponent)\n\n","syntax":"\n\nbase: the number (float)\n\n\nexponent: the power to which the base is raised (float)\n\n"}{"name":"\n\nGenerates a square wave of the specified frequency (and 50% duty cycle) on a pin. A duration can be specified, otherwise the wave continues until a call to noTone(). The pin can be connected to a piezo buzzer or other speaker to play tones.\n\n\nOnly one tone can be generated at a time. If a tone is already playing on a different pin, the call to tone() will have no effect. If the tone is playing on the same pin, the call will set its frequency.\n\n\nUse of the tone() function will interfere with PWM output on pins 3 and 11 (on boards other than the Mega).\n\n\nIt is not possible to generate tones lower than 31Hz. For technical details, see Brett Hagman’s notes.\n\n","description":"\n\ntone(pin, frequency)\n\n\ntone(pin, frequency, duration)\n\n","syntax":"\n\npin: the pin on which to generate the tone\n\n\nfrequency: the frequency of the tone in hertz - unsigned int\n\n\nduration: the duration of the tone in milliseconds (optional) - unsigned long\n\n"}{"name":"\n\nAnalyse if a char is alpha (that is a letter). ","description":" true if thisChar contains a letter.\n\n","syntax":"\n\n\nisAlpha(thisChar)\n\n\n"}{"name":"\n\nAnalyse if a char is a control character. ","description":" true if thisChar is a control character.\n\n","syntax":"\n\n\n`isControl(thisChar)`\n\n\n"}{"name":"\n\nCalculates the square of a number: the number multiplied by itself.\n\n","description":"\n\nsq(x)\n\n","syntax":"\n\nx: the number, any data type\n\n"}{"name":"\n\nThe random function generates pseudo-random numbers.\n\n","description":"\n\nrandom(max)\nrandom(min, max)\n\n","syntax":"\n\nmin - lower bound of the random value, inclusive (optional)\n\n\nmax - upper bound of the random value, exclusive\n\n"}{"name":"\n\nAnalyse if a char is Ascii. ","description":" true if thisChar contains an Ascii character.\n\n","syntax":"\n\n\n`isAscii(thisChar)`\n\n\n"}{"name":"\n\nExtracts the high-order (leftmost) byte of a word (or the second lowest byte of a larger data type).\n\n","description":"\n\nhighByte(x)\n\n","syntax":"\n\nx: a value of any type\n\n"}{"name":"\n\nClears (writes a 0 to) a bit of a numeric variable.\n\n","description":"\n\nbitClear(x, n)\n\n","syntax":"\n\nx: the numeric variable whose bit to clear\n\n\nn: which bit to clear, starting at 0 for the least-significant (rightmost) bit\n\n"}{"name":"\n\nAnalyse if a char is lower case (that is a letter in lower case). ","description":" true if thisChar contains a letter in lower case.\n\n","syntax":"\n\n\n`isLowerCase(thisChar)`\n\n\n"}{"name":"\n","description":"\n\nbitSet(x, n)\n\n","syntax":"\n\nx: the numeric variable whose bit to set\n\n\nn: which bit to set, starting at 0 for the least-significant (rightmost) bit\n\n"}{"name":"\n\n","description":" the number of milliseconds since the Arduino board began running the current program. This number will overflow (go back to zero), after approximately 50 days.\n\n","syntax":"\n\ntime = millis()\n\n"}{"name":"\n\nCalculates the sine of an angle (in radians). The result will be between -1 and 1.\n\n","description":"\n\nsin(rad)\n\n","syntax":"\n\nrad: The angle in Radians (float).\n\n"}{"name":"\n\nDigital Pins With Interrupts\n\n\nThe first parameter to attachInterrupt is an interrupt number. Normally you should use digitalPinToInterrupt(pin) to translate the actual digital pin to the specific interrupt number. For example, if you connect to pin 3, use digitalPinToInterrupt(3) as the first parameter to attachInterrupt.\n\n\n\n\n\n\n\n\nBoard\nDigital Pins Usable For Interrupts\n\n\n\n\nUno, Nano, Mini, other 328-based\n2, 3\n\n\nMega, Mega2560, MegaADK\n2, 3, 18, 19, 20, 21\n\n\nMicro, Leonardo, other 32u4-based\n0, 1, 2, 3, 7\n\n\nZero\nall digital pins, except 4\n\n\nMKR1000 Rev.1\n0, 1, 4, 5, 6, 7, 8, 9, A1, A2\n\n\nDue\nall digital pins\n\n\n101\nall digital pins (Only pins 2, 5, 7, 8, 10, 11, 12, 13 work with CHANGE)\n\n\n\nNotes and Warnings\n\nNote\nInside the attached function, delay() won’t work and the value returned by millis() will not increment. Serial data received while in the function may be lost. You should declare as volatile any variables that you modify within the attached function. See the section on ISRs below for more information.\n\nUsing Interrupts\n\nInterrupts are useful for making things happen automatically in microcontroller programs, and can help solve timing problems. Good tasks for using an interrupt may include reading a rotary encoder, or monitoring user input.\n\n\nIf you wanted to insure that a program always caught the pulses from a rotary encoder, so that it never misses a pulse, it would make it very tricky to write a program to do anything else, because the program would need to constantly poll the sensor lines for the encoder, in order to catch pulses when they occurred. Other sensors have a similar interface dynamic too, such as trying to read a sound sensor that is trying to catch a click, or an infrared slot sensor (photo-interrupter) trying to catch a coin drop. In all of these situations, using an interrupt can free the microcontroller to get some other work done while not missing the input.\n\nAbout Interrupt Service Routines\n\nISRs are special kinds of functions that have some unique limitations most other functions do not have. An ISR cannot have any parameters, and they shouldn’t return anything.\n\n\nGenerally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time, other interrupts will be executed after the current one finishes in an order that depends on the priority they have. millis() relies on interrupts to count, so it will never increment inside an ISR. Since delay() requires interrupts to work, it will not work if called inside an ISR. micros() works initially, but will start behaving erratically after 1-2 ms. delayMicroseconds() does not use any counter, so it will work as normal.\n\n\nTypically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile.\n\n\nFor more information on interrupts, see Nick Gammon’s notes.\n\n","description":"\n\nattachInterrupt(digitalPinToInterrupt(pin), ISR, mode);\t(recommended)\nattachInterrupt(interrupt, ISR, mode);\t(not recommended)\nattachInterrupt(pin, ISR, mode);\t(not recommended Arduino Due, Zero, MKR1000, 101 only)\n\n","syntax":"\n\ninterrupt: \tthe number of the interrupt (int)\npin: \t      the pin number \t            (Arduino Due, Zero, MKR1000 only)\nISR: \t      the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.\nmode: \t     defines when the interrupt should be triggered. Four constants are predefined as valid values:\n\n\n\n\nLOW to trigger the interrupt whenever the pin is low,\n\n\nCHANGE to trigger the interrupt whenever the pin changes value\n\n\nRISING to trigger when the pin goes from low to high,\n\n\nFALLING for when the pin goes from high to low.\nThe Due, Zero and MKR1000 boards allows also:\n\n\nHIGH to trigger the interrupt whenever the pin is high.\n\n\n\n"}{"name":"\n\nAnalyse if a char is an hexadecimal digit (A-F, 0-9). ","description":" true if thisChar contains an hexadecimal digit.\n\n","syntax":"\n\n\n`isHexadecimalDigit(thisChar)`\n\n\n"}{"name":"\n\nReads a bit of a number.\n\n","description":"\n\nbitRead(x, n)\n\n","syntax":"\n\nx: the number from which to read\n\n\nn: which bit to read, starting at 0 for the least-significant (rightmost) bit\n\n"}{}{"name":"\n\nAnalyse if a char is punctuation (that is a comma, a semicolon, an exlamation mark and so on). ","description":" true if thisChar is punctuation.\n\n","syntax":"\n\n\n`isPunct(thisChar)`\n\n\n"}{"name":"\n\nAnalyse if a char is printable with some content (space is printable but has no content). ","description":" true if thisChar is printable.\n\n","syntax":"\n\n\n`isGraph(thisChar)`\n\n\n"}{}{"name":"\n\nAnalyse if a char is alphanumeric (that is a letter or a numbers). ","description":" true if thisChar contains either a number or a letter.\n\n","syntax":"\n\n\n`isAlphaNumeric(thisChar)`\n\n\n"}{"name":"\n\nanalogWriteResolution() is an extension of the Analog API for the Arduino Due.\n\n\nanalogWriteResolution() sets the resolution of the analogWrite() function. It defaults to 8 bits (values between 0-255) for backward compatibility with AVR based boards.\n\n\nThe Due has the following hardware capabilities:\n\n\n\n\n12 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed to 12-bit resolution.\n\n\n2 pins with 12-bit DAC (Digital-to-Analog Converter)\n\n\n\n\nBy setting the write resolution to 12, you can use analogWrite() with values between 0 and 4095 to exploit the full DAC resolution or to set the PWM signal without rolling over.\n\n\nThe Zero has the following hardware capabilities:\n\n\n\n\n10 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed to 12-bit resolution.\n\n\n1 pin with 10-bit DAC (Digital-to-Analog Converter).\n\n\n\n\nBy setting the write resolution to 10, you can use analogWrite() with values between 0 and 1023 to exploit the full DAC resolution\n\n\nThe MKR Family of boards has the following hardware capabilities:\n\n\n\n\n4 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed from 8 (default) to 12-bit resolution.\n\n\n1 pin with 10-bit DAC (Digital-to-Analog Converter)\n\n\n\n\nBy setting the write resolution to 12 bits, you can use analogWrite() with values between 0 and 4095 for PWM signals; set 10 bit on the DAC pin to exploit the full DAC resolution of 1024 values.\n\n","description":"\n\nanalogWriteResolution(bits)\n\n","syntax":"\n\nbits: determines the resolution (in bits) of the values used in the analogWrite() function. The value can range from 1 to 32. If you choose a resolution higher or lower than your board’s hardware capabilities, the value used in analogWrite() will be either truncated if it’s too high or padded with zeros if it’s too low. See the note below for details.\n\n"}{"name":"\n\nCalculates the maximum of two numbers.\n\n","description":"\n\nmax(x, y)\n\n","syntax":"\n\nx: the first number, any data type\ny: the second number, any data type\n\n"}{"name":"\n\nAnalyse if a char is upper case (that is a letter in upper case). ","description":" true if thisChar is upper case.\n\n","syntax":"\n\n\n`isUpperCase(thisChar)`\n\n\n"}