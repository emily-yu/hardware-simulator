[{"description":"Pauses the program for the amount of time (in microseconds) specified as parameter. There are a thousand microseconds in a millisecond, and a million microseconds in a second.Currently, the largest value that will produce an accurate delay is 16383. This could change in future Arduino releases. For delays longer than a few thousand microseconds, you should use delay() instead.","name":"delayMicroseconds(us)","syntax":"us: the number of microseconds to pause (unsigned int)"},{"description":"Reads the value from a specified digital pin, either HIGH or LOW.","name":"digitalRead(pin)","syntax":"pin: the number of the digital pin you want to read"},{"description":"","name":" the number of microseconds since the Arduino board began running the current program. This number will overflow (go back to zero), after approximately 70 minutes. On 16 MHz Arduino boards (e.g. Duemilanove and Nano), this function has a resolution of four microseconds (i.e. the value returned is always a multiple of four). On 8 MHz Arduino boards (e.g. the LilyPad), this function has a resolution of eight microseconds.","syntax":"time = micros()"},{"description":"Calculates the value of a number raised to a power. Pow() can be used to raise a number to a fractional power. This is useful for generating exponential mapping of values or curves.","name":"pow(base, exponent)","syntax":"base: the number (float)exponent: the power to which the base is raised (float)"},{"description":"Configures the reference voltage used for analog input (i.e. the value used as the top of the input range). The options are:Arduino AVR Boards (Uno, Mega, etc.)DEFAULT: the default analog reference of 5 volts (on 5V Arduino boards) or 3.3 volts (on 3.3V Arduino boards)INTERNAL: an built-in reference, equal to 1.1 volts on the ATmega168 or ATmega328P and 2.56 volts on the ATmega8 (not available on the Arduino Mega)INTERNAL1V1: a built-in 1.1V reference (Arduino Mega only)INTERNAL2V56: a built-in 2.56V reference (Arduino Mega only)EXTERNAL: the voltage applied to the AREF pin (0 to 5V only) is used as the reference.Arduino SAMD Boards (Zero, etc.)AR_DEFAULT: the default analog reference of 3.3VAR_INTERNAL: a built-in 2.23V referenceAR_INTERNAL1V0: a built-in 1.0V referenceAR_INTERNAL1V65: a built-in 1.65V referenceAR_INTERNAL2V23: a built-in 2.23V referenceAR_EXTERNAL: the voltage applied to the AREF pin is used as the referenceArduino SAM Boards (Due)AR_DEFAULT: the default analog reference of 3.3V. This is the only supported option for the Due.","name":"analogReference(type)","syntax":"type: which type of reference to use (see list of options in the description)."},{"description":"Reads the value from the specified analog pin. The Arduino board contains a 6 channel (8 channels on the Mini and Nano, 16 on the Mega), 10-bit analog to digital converter. This means that it will map input voltages between 0 and 5 volts into integer values between 0 and 1023. This yields a resolution between readings of: 5 volts / 1024 units or, .0049 volts (4.9 mV) per unit. The input range and resolution can be changed using analogReference().It takes about 100 microseconds (0.0001 s) to read an analog input, so the maximum reading rate is about 10,000 times a second.","name":"analogRead(pin)","syntax":"pin: the number of the analog input pin to read from (0 to 5 on most boards, 0 to 7 on the Mini and Nano, 0 to 15 on the Mega)"},{"description":"Configures the specified pin to behave either as an input or an output. See the description of (digital pins) for details on the functionality of the pins.As of Arduino 1.0.1, it is possible to enable the internal pullup resistors with the mode INPUT_PULLUP. Additionally, the INPUT mode explicitly disables the internal pullups.","name":"pinMode(pin, mode)","syntax":"pin: the number of the pin whose mode you wish to setmode: INPUT, OUTPUT, or INPUT_PULLUP. (see the (digital pins) page for a more complete description of the functionality.)"},{"description":"Stops the generation of a square wave triggered by tone(). Has no effect if no tone is being generated.","name":"noTone(pin)","syntax":"pin: the pin on which to stop generating the tone"},{"description":"Constrains a number to be within a range.","name":"constrain(x, a, b)","syntax":"x: the number to constrain, all data typesa: the lower end of the range, all data typesb: the upper end of the range, all data types"},{},{"description":"Analyse if a char is a digit (that is a number). ","name":" true if thisChar is a number.","syntax":"isDigit(thisChar)"},{"description":"Analyse if a char is Ascii. ","name":" true if thisChar contains an Ascii character.","syntax":"`isAscii(thisChar)`"},{"description":"Writes an analog value (PWM wave) to a pin. Can be used to light a LED at varying brightnesses or drive a motor at various speeds. After a call to analogWrite(), the pin will generate a steady square wave of the specified duty cycle until the next call to analogWrite() (or a call to digitalRead() or digitalWrite()) on the same pin. The frequency of the PWM signal on most pins is approximately 490 Hz. On the Uno and similar boards, pins 5 and 6 have a frequency of approximately 980 Hz.On most Arduino boards (those with the ATmega168 or ATmega328P), this function works on pins 3, 5, 6, 9, 10, and 11. On the Arduino Mega, it works on pins 2 - 13 and 44 - 46. Older Arduino boards with an ATmega8 only support analogWrite() on pins 9, 10, and 11.The Arduino DUE supports analogWrite() on pins 2 through 13, plus pins DAC0 and DAC1. Unlike the PWM pins, DAC0 and DAC1 are Digital to Analog converters, and act as true analog outputs.You do not need to call pinMode() to set the pin as an output before calling analogWrite().The analogWrite function has nothing to do with the analog pins or the analogRead function.","name":"analogWrite(pin, value)","syntax":"pin: the pin to write to. Allowed data types: int.value: the duty cycle: between 0 (always off) and 255 (always on). Allowed data types: int"},{"description":"Shifts in a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit. For each bit, the clock pin is pulled high, the next bit is read from the data line, and then the clock pin is taken low.If you’re interfacing with a device that’s clocked by rising edges, you’ll need to make sure that the clock pin is low before the first call to shiftIn(), e.g. with a call to digitalWrite(clockPin, LOW).Note: this is a software implementation; Arduino also provides an SPI library that uses the hardware implementation, which is faster but only works on specific pins.","name":"byte incoming = shiftIn(dataPin, clockPin, bitOrder)","syntax":"dataPin: the pin on which to input each bit (int)clockPin: the pin to toggle to signal a read from dataPinbitOrder: which order to shift in the bits; either MSBFIRST or LSBFIRST.(Most Significant Bit First, or, Least Significant Bit First)"},{"description":"Generates a square wave of the specified frequency (and 50% duty cycle) on a pin. A duration can be specified, otherwise the wave continues until a call to noTone(). The pin can be connected to a piezo buzzer or other speaker to play tones.Only one tone can be generated at a time. If a tone is already playing on a different pin, the call to tone() will have no effect. If the tone is playing on the same pin, the call will set its frequency.Use of the tone() function will interfere with PWM output on pins 3 and 11 (on boards other than the Mega).It is not possible to generate tones lower than 31Hz. For technical details, see Brett Hagman’s notes.","name":"tone(pin, frequency)tone(pin, frequency, duration)","syntax":"pin: the pin on which to generate the tonefrequency: the frequency of the tone in hertz - unsigned intduration: the duration of the tone in milliseconds (optional) - unsigned long"},{"description":"Calculates the maximum of two numbers.","name":"max(x, y)","syntax":"x: the first number, any data typey: the second number, any data type"},{"description":"","name":"sqrt(x)","syntax":"x: the number, any data type"},{"description":"Computes the value of the specified bit (bit 0 is 1, bit 1 is 2, bit 2 is 4, etc.).","name":"bit(n)","syntax":"n: the bit whose value to compute"},{"description":"Calculates the cosine of an angle (in radians). The result will be between -1 and 1.","name":"cos(rad)","syntax":"rad: The angle in Radians (float)."},{"description":"Re-maps a number from one range to another. That is, a value of fromLow would get mapped to toLow, a value of fromHigh to toHigh, values in-between to values in-between, etc.Does not constrain values to within the range, because out-of-range values are sometimes intended and useful. The constrain() function may be used either before or after this function, if limits to the ranges are desired.Note that the \"lower bounds\" of either range may be larger or smaller than the \"upper bounds\" so the map() function may be used to reverse a range of numbers, for exampley = map(x, 1, 50, 50, 1);The function also handles negative numbers well, so that this exampley = map(x, 1, 50, 50, -100);is also valid and works well.The map() function uses integer math so will not generate fractions, when the math might indicate that it should do so. Fractional remainders are truncated, and are not rounded or averaged.","name":"map(value, fromLow, fromHigh, toLow, toHigh)","syntax":"value: the number to mapfromLow: the lower bound of the value’s current rangefromHigh: the upper bound of the value’s current rangetoLow: the lower bound of the value’s target rangetoHigh: the upper bound of the value’s target range"},{"description":"Pauses the program for the amount of time (in milliseconds) specified as parameter. (There are 1000 milliseconds in a second.)","name":"delay(ms)","syntax":"ms: the number of milliseconds to pause (unsigned long)"},{"description":"Calculates the sine of an angle (in radians). The result will be between -1 and 1.","name":"sin(rad)","syntax":"rad: The angle in Radians (float)."},{"description":"Reads a pulse (either HIGH or LOW) on a pin. For example, if value is HIGH, pulseInLong() waits for the pin to go HIGH, starts timing, then waits for the pin to go LOW and stops timing. ","name":" the length of the pulse in microseconds or 0 if no complete pulse was received within the timeout.The timing of this function has been determined empirically and will probably show errors in shorter pulses. Works on pulses from 10 microseconds to 3 minutes in length. Please also note that if the pin is already high when the function is called, it will wait for the pin to go LOW and then HIGH before it starts counting. This routine can be used only if interrupts are activated. Furthermore the highest resolution is obtained with large intervals.","syntax":"pulseInLong(pin, value)pulseInLong(pin, value, timeout)"},{"description":"Reads a pulse (either HIGH or LOW) on a pin. For example, if value is HIGH, pulseIn() waits for the pin to go HIGH, starts timing, then waits for the pin to go LOW and stops timing. ","name":" the length of the pulse in microseconds. Gives up and returns 0 if no pulse starts within a specified time out.The timing of this function has been determined empirically and will probably show errors in longer pulses. Works on pulses from 10 microseconds to 3 minutes in length.","syntax":"pulseIn(pin, value)pulseIn(pin, value, timeout)"},{"description":"Analyse if a char is alphanumeric (that is a letter or a numbers). ","name":" true if thisChar contains either a number or a letter.","syntax":"`isAlphaNumeric(thisChar)`"},{"description":"Analyse if a char is lower case (that is a letter in lower case). ","name":" true if thisChar contains a letter in lower case.","syntax":"`isLowerCase(thisChar)`"},{"description":"Write a HIGH or a LOW value to a digital pin.If the pin has been configured as an OUTPUT with pinMode(), its voltage will be set to the corresponding value: 5V (or 3.3V on 3.3V boards) for HIGH, 0V (ground) for LOW.If the pin is configured as an INPUT, digitalWrite() will enable (HIGH) or disable (LOW) the internal pullup on the input pin. It is recommended to set the pinMode() to INPUT_PULLUP to enable the internal pull-up resistor. See the digital pins tutorial for more information.If you do not set the pinMode() to OUTPUT, and connect an LED to a pin, when calling digitalWrite(HIGH), the LED may appear dim. Without explicitly setting pinMode(), digitalWrite() will have enabled the internal pull-up resistor, which acts like a large current-limiting resistor.","name":"digitalWrite(pin, value)","syntax":"pin: the pin numbervalue: HIGH or LOW"},{"description":"Analyse if a char is punctuation (that is a comma, a semicolon, an exlamation mark and so on). ","name":" true if thisChar is punctuation.","syntax":"`isPunct(thisChar)`"},{"description":"Analyse if a char is an hexadecimal digit (A-F, 0-9). ","name":" true if thisChar contains an hexadecimal digit.","syntax":"`isHexadecimalDigit(thisChar)`"},{"description":"Analyse if a char is printable with some content (space is printable but has no content). ","name":" true if thisChar is printable.","syntax":"`isGraph(thisChar)`"},{"description":"Extracts the low-order (rightmost) byte of a variable (e.g. a word).","name":"lowByte(x)","syntax":"x: a value of any type"},{"description":"Extracts the high-order (leftmost) byte of a word (or the second lowest byte of a larger data type).","name":"highByte(x)","syntax":"x: a value of any type"},{"description":"The random function generates pseudo-random numbers.","name":"random(max)random(min, max)","syntax":"min - lower bound of the random value, inclusive (optional)max - upper bound of the random value, exclusive"},{"description":"Analyse if a char is a white space, that is space, formfeed ('\f'), newline ('\\'), carriage return ('\\'), horizontal tab ('\\'), and vertical tab ('\\')).","name":" true if thisChar contains a white space.","syntax":"isWhitespace(thisChar)"},{"description":"","name":" the number of milliseconds since the Arduino board began running the current program. This number will overflow (go back to zero), after approximately 50 days.","syntax":"time = millis()"},{"description":"Calculates the absolute value of a number.","name":"abs(x)","syntax":"x: the number"},{"description":"analogWriteResolution() is an extension of the Analog API for the Arduino Due.analogWriteResolution() sets the resolution of the analogWrite() function. It defaults to 8 bits (values between 0-255) for backward compatibility with AVR based boards.The Due has the following hardware capabilities:12 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed to 12-bit resolution.2 pins with 12-bit DAC (Digital-to-Analog Converter)By setting the write resolution to 12, you can use analogWrite() with values between 0 and 4095 to exploit the full DAC resolution or to set the PWM signal without rolling over.The Zero has the following hardware capabilities:10 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed to 12-bit resolution.1 pin with 10-bit DAC (Digital-to-Analog Converter).By setting the write resolution to 10, you can use analogWrite() with values between 0 and 1023 to exploit the full DAC resolutionThe MKR Family of boards has the following hardware capabilities:4 pins which default to 8-bit PWM, like the AVR-based boards. These can be changed from 8 (default) to 12-bit resolution.1 pin with 10-bit DAC (Digital-to-Analog Converter)By setting the write resolution to 12 bits, you can use analogWrite() with values between 0 and 4095 for PWM signals; set 10 bit on the DAC pin to exploit the full DAC resolution of 1024 values.","name":"analogWriteResolution(bits)","syntax":"bits: determines the resolution (in bits) of the values used in the analogWrite() function. The value can range from 1 to 32. If you choose a resolution higher or lower than your board’s hardware capabilities, the value used in analogWrite() will be either truncated if it’s too high or padded with zeros if it’s too low. See the note below for details."},{"description":"Writes a bit of a numeric variable.","name":"bitWrite(x, n, b)","syntax":"x: the numeric variable to which to writen: which bit of the number to write, starting at 0 for the least-significant (rightmost) bitb: the value to write to the bit (0 or 1)"},{"description":"Digital Pins With InterruptsThe first parameter to attachInterrupt is an interrupt number. Normally you should use digitalPinToInterrupt(pin) to translate the actual digital pin to the specific interrupt number. For example, if you connect to pin 3, use digitalPinToInterrupt(3) as the first parameter to attachInterrupt.BoardDigital Pins Usable For InterruptsUno, Nano, Mini, other 328-based2, 3Mega, Mega2560, MegaADK2, 3, 18, 19, 20, 21Micro, Leonardo, other 32u4-based0, 1, 2, 3, 7Zeroall digital pins, except 4MKR1000 Rev.10, 1, 4, 5, 6, 7, 8, 9, A1, A2Dueall digital pins101all digital pins (Only pins 2, 5, 7, 8, 10, 11, 12, 13 work with CHANGE)Notes and WarningsNoteInside the attached function, delay() won’t work and the value returned by millis() will not increment. Serial data received while in the function may be lost. You should declare as volatile any variables that you modify within the attached function. See the section on ISRs below for more information.Using InterruptsInterrupts are useful for making things happen automatically in microcontroller programs, and can help solve timing problems. Good tasks for using an interrupt may include reading a rotary encoder, or monitoring user input.If you wanted to insure that a program always caught the pulses from a rotary encoder, so that it never misses a pulse, it would make it very tricky to write a program to do anything else, because the program would need to constantly poll the sensor lines for the encoder, in order to catch pulses when they occurred. Other sensors have a similar interface dynamic too, such as trying to read a sound sensor that is trying to catch a click, or an infrared slot sensor (photo-interrupter) trying to catch a coin drop. In all of these situations, using an interrupt can free the microcontroller to get some other work done while not missing the input.About Interrupt Service RoutinesISRs are special kinds of functions that have some unique limitations most other functions do not have. An ISR cannot have any parameters, and they shouldn’t return anything.Generally, an ISR should be as short and fast as possible. If your sketch uses multiple ISRs, only one can run at a time, other interrupts will be executed after the current one finishes in an order that depends on the priority they have. millis() relies on interrupts to count, so it will never increment inside an ISR. Since delay() requires interrupts to work, it will not work if called inside an ISR. micros() works initially, but will start behaving erratically after 1-2 ms. delayMicroseconds() does not use any counter, so it will work as normal.Typically global variables are used to pass data between an ISR and the main program. To make sure variables shared between an ISR and the main program are updated correctly, declare them as volatile.For more information on interrupts, see Nick Gammon’s notes.","name":"attachInterrupt(digitalPinToInterrupt(pin), ISR, mode);(recommended)attachInterrupt(interrupt, ISR, mode);(not recommended)attachInterrupt(pin, ISR, mode);(not recommended Arduino Due, Zero, MKR1000, 101 only)","syntax":"interrupt: the number of the interrupt (int)pin:       the pin number             (Arduino Due, Zero, MKR1000 only)ISR:       the ISR to call when the interrupt occurs; this function must take no parameters and return nothing. This function is sometimes referred to as an interrupt service routine.mode:      defines when the interrupt should be triggered. Four constants are predefined as valid values:LOW to trigger the interrupt whenever the pin is low,CHANGE to trigger the interrupt whenever the pin changes valueRISING to trigger when the pin goes from low to high,FALLING for when the pin goes from high to low.The Due, Zero and MKR1000 boards allows also:HIGH to trigger the interrupt whenever the pin is high."},{"description":"Analyse if a char is a control character. ","name":" true if thisChar is a control character.","syntax":"`isControl(thisChar)`"},{"description":"Calculates the square of a number: the number multiplied by itself.","name":"sq(x)","syntax":"x: the number, any data type"},{"description":"Clears (writes a 0 to) a bit of a numeric variable.","name":"bitClear(x, n)","syntax":"x: the numeric variable whose bit to clearn: which bit to clear, starting at 0 for the least-significant (rightmost) bit"},{"description":"Calculates the minimum of two numbers.","name":"min(x, y)","syntax":"x: the first number, any data typey: the second number, any data type"},{"description":"Calculates the tangent of an angle (in radians). The result will be between negative infinity and infinity.","name":"tan(rad)","syntax":"rad: The angle in Radians (float)."},{"description":"Reads a bit of a number.","name":"bitRead(x, n)","syntax":"x: the number from which to readn: which bit to read, starting at 0 for the least-significant (rightmost) bit"},{"description":"Shifts out a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit. Each bit is written in turn to a data pin, after which a clock pin is pulsed (taken high, then low) to indicate that the bit is available.Note- if you’re interfacing with a device that’s clocked by rising edges, you’ll need to make sure that the clock pin is low before the call to shiftOut(), e.g. with a call to digitalWrite(clockPin, LOW).This is a software implementation; see also the SPI library, which provides a hardware implementation that is faster but works only on specific pins.","name":"shiftOut(dataPin, clockPin, bitOrder, value)","syntax":"dataPin: the pin on which to output each bit (int)clockPin: the pin to toggle once the dataPin has been set to the correct value (int)bitOrder: which order to shift out the bits; either MSBFIRST or LSBFIRST.(Most Significant Bit First, or, Least Significant Bit First)value: the data to shift out. (byte)"},{"description":"Analyse if a char is alpha (that is a letter). ","name":" true if thisChar contains a letter.","syntax":"isAlpha(thisChar)"},{"description":"randomSeed() initializes the pseudo-random number generator, causing it to start at an arbitrary point in its random sequence. This sequence, while very long, and random, is always the same.If it is important for a sequence of values generated by random() to differ, on subsequent executions of a sketch, use randomSeed() to initialize the random number generator with a fairly random input, such as analogRead() on an unconnected pin.Conversely, it can occasionally be useful to use pseudo-random sequences that repeat exactly. This can be accomplished by calling randomSeed() with a fixed number, before starting the random sequence.","name":"seed - number to initialize the pseudo-random sequence (unsigned long)."},{"description":"Re-enables interrupts (after they’ve been disabled by nointerrupts(). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code.","name":"interrupts()","syntax":"Nothing"},{"description":"Disables interrupts (you can re-enable them with interrupts()). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code.","name":"noInterrupts()","syntax":"Nothing"},{},{"description":"Analyse if a char is the space character. ","name":" true if thisChar contains the space character.","syntax":"`isSpace(thisChar)`"},{},{"description":"Analyse if a char is printable (that is any character that produces an output, even a blank space). ","name":" true if thisChar is printable.","syntax":"`isAlpha(thisChar)`"},{"description":"Turns off the given interrupt.","name":"detachInterrupt()detachInterrupt(pin) (Arduino Due only)","syntax":"interrupt: the number of the interrupt to disable (see attachInterrupt() for more details).pin: the pin number of the interrupt to disable (Arduino Due only)"},{"description":"","name":"bitSet(x, n)","syntax":"x: the numeric variable whose bit to setn: which bit to set, starting at 0 for the least-significant (rightmost) bit"},{},{"description":"Analyse if a char is upper case (that is a letter in upper case). ","name":" true if thisChar is upper case.","syntax":"`isUpperCase(thisChar)`"},{"description":"analogReadResolution() is an extension of the Analog API for the Arduino Due, Zero and MKR Family.Sets the size (in bits) of the value returned by analogRead(). It defaults to 10 bits (returns values between 0-1023) for backward compatibility with AVR based boards.The Due, Zero and MKR Family boards have 12-bit ADC capabilities that can be accessed by changing the resolution to 12. This will return values from analogRead() between 0 and 4095.","name":"analogReadResolution(bits)","syntax":"bits: determines the resolution (in bits) of the value returned by the analogRead() function. You can set this between 1 and 32. You can set resolutions higher than 12 but values returned by analogRead() will suffer approximation. See the note below for details."}]
